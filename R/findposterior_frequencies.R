#' Perform a Bayesian Update of Allele Frequencies for One Locus
#'
#' @description
#' A core step within the Gibbs sampler that updates the population allele
#' frequencies for a single locus. It uses a Dirichlet-Multinomial conjugate
#' model to combine prior beliefs with the current state of imputed allele data
#' from the MCMC.
#'
#' @details
#' This function performs a Bayesian update for the allele frequencies of a
#' single locus. It assumes a non-informative Dirichlet prior (alpha parameters
#' set to 1). The 'observed data' for this step is the current state of the
#' imputed true alleles (`tempdata`) from the Gibbs sampler.
#'
#' The posterior distribution is then calculated by adding the observed allele
#' counts to the prior parameters. A single random draw is taken from this
#' posterior Dirichlet distribution to be used as the fixed allele frequencies
#' for the next iteration of the Gibbs sampler.
#'
#' @param locus_index The numeric index of the locus to update.
#' @param tempdata A matrix representing the current imputed state of true
#'   alleles for all samples. Rows are samples, and columns are grouped by
#'   locus and MOI. It's a key component of the MCMC state.
#' @param maxMOI An integer specifying the maximum multiplicity of infection,
#'   which determines the number of columns per locus in `tempdata`.
#' @param frequencies_RR The list object containing population genetic
#'   statistics, as generated by `calculate_frequencies3`. This provides the
#'   number of alleles (`n_alleles`) and their codes (`allele_codes`) for the
#'   locus.
#'
#' @return A numeric vector representing a *single random sample* from the
#'   posterior distribution of allele frequencies for the specified locus.
#'   The length of the vector corresponds to the number of unique alleles
#'   at that locus.
#'
#' @keywords internal
#' @noRd
#'

findposteriorfrequencies =  function(locus_index, tempdata, maxMOI, frequencies_RR) {
  data_cols <- (1:maxMOI) + (locus_index - 1) * maxMOI
  locus_data <- tempdata[, data_cols]
  n_alleles <- frequencies_RR$n_alleles[locus_index]
  
  if (is.na(n_alleles) || n_alleles == 0) {
    max_alleles_in_matrix <- ncol(frequencies_RR$freq_matrix)
    return(rep(NA, max_alleles_in_matrix))
  }
  allele_levels <- frequencies_RR$allele_codes[[locus_index]]
  freq_prior_alpha <- rep(1, n_alleles)
  observed_counts <- table(factor(c(locus_data), levels = allele_levels))
  freq_posterior_alpha <- freq_prior_alpha + observed_counts
  new_frequencies <- gtools::rdirichlet(1, freq_posterior_alpha)
  return(as.vector(new_frequencies))
}
